
　　C++ で紡ぐＲＸマイコン物語

－－－－－－－－－－－－－－－－－－－－－－－－－

はじまり

昨今、ホビーでも仕事でも、強力なＰＣがある状況では、何でもやりたい事が出来てしまいます。
今のＰＣは一昔前のスーパーコンピューターより強力な演算能力、メモリー、二次記憶を持っています。
昔、数億円していたものが現在では数万円で誰でも買えて、使う事が出来るのです。
また、ネットにアクセスすれば、どんな情報でも殆ど揃っている状況です。

身の回りの電化製品には当然のようにマイコンが組み込まれて、様々な作業をこなし、人間の活動に介入しており、生活を豊かにしています。

「組み込みマイコン」は、非常に小さい規模で使われるマイクロコンピューターで、ＰＣとは異なる作業を分担をしており、比較的単純な作業から複雑怪奇な作業をしています。

ＰＣ上で動くアプリケーションと同様に、組み込みマイコンでもプログラミングを行う作業は必須ですが、ＰＣ上のアプリケーションでは、プログラムを作成すれば、直に動作を確認できますが、組み込みマイコンの場合、作成したプログラムを組み込みマイコン上にロードして動作させるのでｍ間接的で、その手間や仕組みを理解する必要があります。


－－－－－－－－－－－－－－－－－－－－－－－－－

どんな言語を習得すべきなのか？


コンピュータ言語を習得する場合、どの言語が良いのでしょうか？
※入門者の人にこのような質問を良く聞かれます。

大雑把に、二つの異なるアプローチを考えてみます。
・気の向くまま、様々な言語を少しづつかじって、広く浅く
・一つの言語だけをとことん追求して、狭く深く
これら二つのアプローチは、ビルの高さと景色に例える事が出来ると思います。

「広く浅く」の場合、色々なビルに登る事で、広範囲な知識や経験を獲得する事が出来ます。
一方「狭く広く」では、一つのビルだけに登る事で、一つの分野に特化した十分な知識を得られます。
しかし、色々なビルに登って景色を眺めてみると、確かに色々な景色を眺める事は出来ますが、低い場所から眺める景色は所詮制限されたものです、高い場所から眺める景色とは全く異なります。

私が薦めたいのは、まず、一つの言語をとことん追求して、ある程度の高さまで登ってしまう事です、一度、ある程度の高さまで達すると、別のビルの同じ高さから眺める景色と大して変わりません。
※一つの言語をある程度学んでいれば、異なった言語の習得にかかる労力は少ないと感じます。

高い場所に登るには、時間が必要で、一朝一夕には到達しない事を

～～～～～～～

・マイコンに最大の仕事をさせるプログラミング言語とは？
マイクロコントローラーをもっとも効率的に動かせる言語はアセンブラかもしれません。
「かもしれない」と疑問形なのは、コンパイラの能力が進歩しているので、高級言語と呼ばれるコンピューター言語が凌駕する場合があると思われるからです。


～～～～～～～

・ＲＸマイコンにおける最高の開発環境とはどんなものか？

(1) 
(x) boost をコンパイル出来ない C++ コンパイラは不適格なコンパイラと言える。
(x) 少なくとも２０１９年の時点で、C++11、C++14、C++17 を完全にサポートしていないコンパイラは不適格なコンパイラと言える。
※「不適格なコンパイラ」とは「C++ コンパイラではない」と断言できる。


～～～～～～～

・オープンソースのコンパイラを利用する意味

gcc はサポートしている CPU の数において群を抜いています。
また、C++ 標準化委員会の勧告を適切に実装しており、エラー検出、最適化にも配慮がなされています。



～～～～～～～

・デバッグ環境について
ソースコードデバッガーとＩＣＥ（インサーキットエミュレーター）の組み合わせは、非常に強力で柔軟な開発環境を提供してきました。
一旦この環境が浸透してしまうと、精神的にも、肉体的（物理的）にもこの環境から抜け出せない開発者が多く発生してしまい、応用したり工夫する力、想像や推定など、基本的な能力が衰退してしまいました。

ＩＣＥは、非常に高速なクロックでドライブされるマイクロプロセッサには物理的に適合しなくなってきてしまいましたが、ＬＳＩの物理的な検査を行う為に発達してきたＪ－ＴＡＧ技術を拡張する事で、ＩＣＥの代わりになる事が浸透して、現在では、マイクロコントローラーのデバッグ環境の定番技術となっています。

ほとんどの技術者は、Ｊ－ＴＡＧ等による開発環境が無い現場を敬遠して、これが無いと「まともな開発」は出来ないものと認識している人が多数いる現実があります。

一方、何かの組み込み開発で、ソフトウェアーやハードウェアーの不具合から、想定した動作をしない状態に陥ると、「まともな開発環境」が無い状態では抜け出せない開発者が多数います、また、このような状況を目の当たりにしている為、「まともな開発環境が無い」世界に恐れを抱いているのです。
この「恐れ」は、経験不足や、想像力の欠落などからくるものですが、それさえ認識していない人が多くいる事に大変危機感を持っています。

「まともなデバッグ環境が無い」事は、マイナス要因ではありますが、決定的な要因ではありません、「ステップ実行」が無い為に原因を特定出来ない


～～～～～～～

・boost を使う意味



～～～～～～～

・C++ に対する誤解と偏見

C 言語を常用する開発者に多いのですが、C++ に対する「誤解」が非常に多い事に驚きます。
※自分も C++ を始めた頃、「ネガティブ」な感情を持っていました。

いくつかの例として・・
・メモリーを多く消費する（そんな事は全くありません）
・C で作った方が高速に動作する（全くの間違いです）
・アセンブラに近い C 言語の方が最適化に有利（殆どの場合、C++ で「適切」に実装した方が最適化が巧妙に適用され、高速に動作します）





～～～～～～～

・開発環境を整える


～～～～～～～

・RX マイコン用 gcc をビルドする


～～～～～～～

・Makefile を利用する


～～～～～～～

・RX65N Envision Kit


～～～～～～～

・gcc で生成する実行形式のイロハ


～～～～～～～

・LED 点滅

～～～～～～～

・標準出力 printf の基本的な仕組み

printf 関数を呼んだ場合、どのような機構で文字が出力されるのかを簡単に解説します。

printf 関数は文字出力を行うのにファイル出力を利用しています。
通常アプリケーションが起動した段階で、「stdout、stdin、stderr」と３つのファイルディスクリプタが定義された状態になっています。
stdin:  ０
stdout: １
stderr: ２
それぞれ、０、１，２番のファイルＩＤが割り当ててあります。
つまり、printf を呼ぶと、上記のファイルディスクリプタを使って、出力する文字の数だけ「write」関数が呼ばれます。
gcc のアプリケーションでは、POSIX の標準関数は、特別な定義になっていて、もしアプリケーション内に、write 関数の実装が存在すれば（リンク時に見つかれば）、その関数が優先される仕組みがあります。
※具体的には、ヘッダーで、以下のように定義されています。
int write(int fd, const void *ptr, int len) __attribute__((weak));
※「__attribute__((weak))」がある事で、アプリケーション定義のAPIが優先されます。

従って、write 関数内で「fd == 1」の場合に、シリアル出力するようにしておけば、printf 関数を呼べばそのままシリアル出力に流れていきます。

この仕組みは「common/syscalls.c」に実装があります。

また、シリアル出力として「sci_putch(char ch)」関数をユーザーのアプリ内で C言語の API として定義しておきます。

extern "C" {

    // syscalls.c から呼ばれる、標準出力（stdout, stderr）
    void sci_putch(char ch)
    {
        sci_.putch(ch);
    }

}

～～～～～～～

・printf を使うな！

C 言語のプログラマや、組み込みプログラマの多くは、printf を何の疑いもなく利用していますが、この API は大きな欠陥があり、互換性の為だけに用意されています。
一番の問題は、可変引数です。
これは、引数の受け渡しをスタックベースで行い、printf 内のフォーマット文字列と、引数の不整合は、プログラムを簡単にクラッシュさせてしまいます。
この「不整合」はある程度はコンパイラが検出しますが完全では無く、完全なエラーの検出も出来ません。

通常「現場」では、printf のような可変引数の利用は厳禁としており、使う事を禁止しています。
※その為、C++ では iostream に代表される仕組みが採用されています。

しかしながら、printf に備わっている仕組みは「手っ取り早く魅力的」でもあります、そこで C++ ではこれに似た仕様を安全な方法で提供しています。
それが、format.hpp クラスです。


～～～～～～～

・Makefile の勘所



～～～～～～～

・C++ トピック（一時変数）

未だに、変数をまとめて関数の頭で宣言したり、一つの変数を使いまわしたりしている人がいますが、現代のコンパイラでは、このような書き方は弊害しかありません。

ＮＧ：
    int i, j, k;
	k = 0;
	for(i = 0; i < 10; i++) {
	    j = getch();
		if(j == EOF) break;
		k++;
	}
    for(i = 0; i < k; i++) {
	
	}
ＧＯＯＤ：
    int k = 0;
	for(int i = 0; i < 10; i++) {
	    int j = getch();  // 又は「  auto j = getch();  」
		if(j == EOF) break;
		k++;
	}
    for(int i = 0; i < k; i++) {
	
	}
※変数は、使いたい時にその手前で宣言するか、内包すれば良いのです。
※使いまわす事に何の意味（余分なメモリの節約？）もありません。


